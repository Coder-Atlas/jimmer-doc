---
sidebar_position: 4
title: APT/KSP
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';
import Precompiler from '../_shared/precompiler.mdx';

## Basic Concepts

Jimmer heavily relies on the precompilation technology in the JVM ecosystem:

-   For Java, it's `APT`, i.e., [Annotation Processor Tool](https://www.jetbrains.com/help/idea/annotation-processors-support.html)

-   For Kotlin, it's `KSP`, i.e., [Kotlin Symbol Processing](https://kotlinlang.org/docs/ksp-overview.html)

:::info
Some code generated by APT/KSP is necessary for using Jimmer.

Therefore, if you open any Java/Kotlin project from the [official examples](https://github.com/babyfish-ct/jimmer-examples) in IntelliJ, you will find that some code that should have been automatically generated is missing. For this, you can choose any of the following methods:

-   First, execute the `./mvnw install` *(for Java examples only)* or `./gradlew build` command in the directory of the project you want to open from the command line to complete the code generation, then open the project with IntelliJ.

-   Open the project directly with IntelliJ, ignore the IDE errors temporarily, and after the dependencies are downloaded, run the project's main method or unit test *(save-command/save-command-kt demonstrates features using unit tests)*. All IDE errors will automatically disappear, and the application will start correctly.
:::

## Notes

Since Jimmer is a compile-time framework, and considering that not all users are familiar with `apt` and `ksp`, it's necessary to mention an important detail. 

`Apt/Ksp` are standard technologies in the industry, and Java IDEs provide support for them.

-   In most cases, your modifications will include changes to Java or Kotlin code, such as changes in entity types or Web Controller*(Jimmer has its own implementations for OpenAPI and TypeScript generation)*. In this case, you only need to click the IDE's `Run` or `Debug` button once, without requiring a full compilation, to trigger all pre-compilation behaviors, the automatically generated source code and resource files will update automatically.

-   In rare cases, if you only modify DTO files, meaning there are no Java or Kotlin source code changes within the same project except for the DTO files, you have three options:

    -   Use the companion DTO plugin
    -   Perform a full compilation using maven or gradle commands, or the IDE's `Rebuild` button, which can achieve this purpose
    -   Delete the affected project's compilation output directory, then click the IDE's `Run` or `Debug` button`
    
## Two Styles of Java Code

Unlike the Kotlin API, the Java API cannot avoid to directly use automatically generate types in user code. Let's compare the following:

<table>
<thead>
<th>Feature</th>
<th>Java</th>
<th>Kotlin</th>
</thead>
<tbody>
<tr>
<td rowspan="2">Draft</td>
<td>Use the generated type `BookDraft`</td>
<td>Use the original entity type `Book`</td>
</tr>
<tr>
<td>

```java
Book book = 
    // highlight-next-line
    BookDraft.$.produce(b -> {
        b.setName("SQL");
        b.addIntoAuthors(a -> {
            a.setName("Jessica");
        });
        b.addIntoAuthors(a -> {
            a.setName("Bob");
        });
    });
```

</td>
<td>

```kotlin
val book =
    // highlight-next-line
    Book {
        name = "SQL in Action"
        authors().addBy {
            name = "Jessica"
        }
        authors().addBy {
            name = "Bob"
        }
    }
```

</td>
</tr>
<tr>
<td rowspan="2">SQL DSL</td>
<td>Use the generated type `BookTable`</td>
<td>Use the original entity type `Book`</td>
</tr>
<tr>
<td>

```java
// highlight-next-line
BookTable table = BookTable.$;

List<Book> books = sqlClient
    .createQuery(table)
    .where(table.storeId().isNull())
    .orderBy(table.name())
    .select(table)
    .execute();
```

</td>
<td>

```kotlin
List<Book> books = sqlClient
    // highlight-next-line
    .createQuery(Book::class) {
        where(table.storeId.isNull())
        orderBy(table.name)
        select(table)
    }
    .execute()
```

</td>
</tr>
<tr>
<td rowspan="2">Fetcher</td>
<td>Use the generated types `BookFetcher`, `BookStoreFetcher`, and `AuthorFetcher`</td>
<td>Use the original entity type `Book`</td>
</tr>
<tr>
<td>

```java
Fetcher<Book> fetcher =
    // highlight-next-line
    BookFetcher.$
        .allScalarFields()
        .store(
            // highlight-next-line
            BookStoreFetcher.$
                .allScalarFields()
        )
        .authors(
            // highlight-next-line
            AuthorFetcher.$
                .allScalarFields()
        )
```

</td>
<td>

```kotlin
val fetcher = 
    // highlight-next-line
    newFetcher(Book::class).by {
        allScalarFields()
        store {
            allScalarFields()
        }
        authors {
            allScalarFields()
        }
    }
```

</td>
</tr>
</tbody>
</table>

As you can see, the abstraction capabilities of Java and Kotlin are different, resulting in different effects that the API design can achieve:

-   For Kotlin, regardless of the scenario, you only need to use the original entity type `Book`.

-   For Java, you have to use the types automatically generated by the Annotation Processor, such as `BookDraft`, `BookTable`, `BookFetcher`, etc.

    In the above Java code, `.$` appears frequently, `$` are static read-only fields of these classes.

Actually, using `$` is the simplest way. However, considering that some Java developers have subjective biases against `$`, for Java subprojects defining entity types, Jimmer's APT also generate four summary types:

-   `Objects` class

-   `Tables` interface

-   `TableExes` interface

-   `Fetchers` interface

The package where these four types reside is the common package for all entities.

These four types provide another coding style for Java code by defining static constants, and the two styles are compared as follows:

|Style Accepting `$`|Style Not Accepting `$`|
|---|----|
|BookDraft.$.produce|Immutables.createBook|
|BookTable.$|Tables.BOOK_TABLE|
|BookTableEx.$|TableExes.BOOK_TABLE_EX|
|BookFetcher.$|Fetchers.BOOK_FETCHER|

Additionally, `Tables`, `TableExes`, and `Fetchers` are interfaces, and you can use the `implements` statement to further simplify the code *(since IntelliJ does not support static imports well, implementing interfaces that define constants is still a recommended technique)*. For example:

```java
public interface FetcherConstants
// highlight-next-line
implements Fetchers {
    
    Fetcher<Book> BOOK_DETAIL_FETCHER =
        BOOK_FETCHER
            .allScalarFields()
            .store(
                BOOK_STORE_FETCHER
                    .allScalarFields()
            )
            .authors {
                AUTHOR_FETCHER
                    .allScalarFields()
            };
}
```
