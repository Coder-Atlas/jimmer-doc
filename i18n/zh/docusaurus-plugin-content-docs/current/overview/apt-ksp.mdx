---
sidebar_position: 4
title: APT/KSP
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

## 基本概念

Jimmer高度依赖于JVM生态的预编译技术：

-   对于Java而言，就是APT，即[Annotation Processor Tool](https://www.jetbrains.com/help/idea/annotation-processors-support.html)

-   Kotlin而言，就是KSP，即[Kotlin Symbol Processing](https://kotlinlang.org/docs/ksp-overview.html)

:::info
使用APT/KSP自动生成的一些代码，是使用Jimmer所必须的。

因此，如果使用Intellij打开[官方例子](https://github.com/babyfish-ct/jimmer-examples)中的任何一个Java/Kotlin项目，都会发现一些本该被自动生成代码并不存在的问题。对此，可以选择以下任何一种方法：

-   先用命令行在要打开的项目目录下执行`./mvnw install`*(仅Java例子提供)*或`./gradlew build`命令完成代码生成，再用Intellij打开项目。

-   直接用Intellij打开项目，暂时无视IDE的错误，依赖下载完毕后，直接运行项目的main方法或单元测试 *(save-command/save-command-kt以单元测试演示功能)*，所有IDE错误将会自动消失，应用也会被正确启动。
:::

## 注意事项

由于Jimmer是一个编译时框架，考虑到并非所有用户都熟悉Apt和Ksp，有必要提及一个重要细节。

Apt/Ksp是行业内的标准技术，Java IDE会给予支持。

-   大部分情况下，你的修改都会包含Java或Kotlin代码的变化，
    例如，实体类型变化，或Web Controller变化 *(Jimmer有自己的OpenAPI和TypeScript生成的实现)*。这时只需点击IDE的Run或Debug按钮运行一次，无需全量编译，就可以触发所有的预编译行为，自动生成的源代码和资源文件都会自动变化

-   少部分情况下，如果仅仅修改DTO文件，即，除了DTO文件外，同一个工程内没有任何Java或Kotlin源码变动，这时，你有三个选择
    -   采用配套的DTO插件
    -   全量编译，maven或gradle命令，或IDE的Rebuild按钮，都可以达到这个目的
    -   删除受影响工程的编译输出目录后，再点击IDE的Run或Debug按钮

## Java代码的两种风格

和Kotlin API不同，Java API做不到自动生成的类型不出现在用户代码中。请看如下对比

<table>
<thead>
<th>功能</th>
<th>Java</th>
<th>Kotlin</th>
</thead>
<tbody>
<tr>
<td rowspan="2">Draft</td>
<td>使用生成的类型`BookDraft`</td>
<td>使用原实体类型`Book`</td>
</tr>
<tr>
<td>

```java
Book book = 
    // highlight-next-line
    BookDraft.$.produce(b -> {
        b.setName("SQL");
        b.addIntoAuthors(a -> {
            a.setName("Jessica");
        });
        b.addIntoAuthors(a -> {
            a.setName("Bob");
        });
    });
```

</td>
<td>

```kotlin
val book =
    // highlight-next-line
    Book {
        name = "SQL in Action"
        authors().addBy {
            name = "Jessica"
        }
        authors().addBy {
            name = "Bob"
        }
    }
```

</td>
</tr>
<tr>
<td rowspan="2">SQL DSL</td>
<td>使用生成的类型`BookTable`</td>
<td>使用原实体类型`Book`</td>
</tr>
<tr>
<td>

```java
// highlight-next-line
BookTable table = BookTable.$;

List<Book> books = sqlClient
    .createQuery(table)
    .where(table.storeId().isNull())
    .orderBy(table.name())
    .select(table)
    .execute();
```

</td>
<td>

```kotlin
List<Book> books = sqlClient
    // highlight-next-line
    .createQuery(Book::class) {
        where(table.storeId.isNull())
        orderBy(table.name)
        select(table)
    }
    .execute()
```

</td>
</tr>
<tr>
<td rowspan="2">Fetcher</td>
<td>使用生成的类型`BookFetcher`, `BookStoreFetcher`和`AuthorFetcher`</td>
<td>使用原实体类型`Book`</td>
</tr>
<tr>
<td>

```java
Fetcher<Book> fetcher =
    // highlight-next-line
    BookFetcher.$
        .allScalarFields()
        .store(
            // highlight-next-line
            BookStoreFetcher.$
                .allScalarFields()
        )
        .authors(
            // highlight-next-line
            AuthorFetcher.$
                .allScalarFields()
        )
```

</td>
<td>

```kotlin
val fetcher = 
    // highlight-next-line
    newFetcher(Book::class).by {
        allScalarFields()
        store {
            allScalarFields()
        }
        authors {
            allScalarFields()
        }
    }
```

</td>
</tr>
</tbody>
</table>

可以看到，Java和Kotlin的抽象能力不同，导致API设计能达到的效果不同：

-   对于Kotlin而言，无论何种场景，都只需使用原实体类型`Book`。

-   对于Java而言，不得不使用由Annotation Processor自动生成的类型，例如`BookDraft`, `BookTable`, `BookFetcher`等。

    上述Java代码中频繁出现`.$`，`$`这些类的静态只读字段。

其实，使用`$`是最简单的使用方式。然而，考虑到部分Java开发人员对`$`存在主观偏见，对定义实体类型的Java子项目而言，
Jimmer的APT还是生成4个汇总类型:

-   `Objects`类

-   `Tables`接口

-   `TableExes`接口

-   `Fetchers`接口

这4个类型所在的包，为所有实体的公共包。

这4个类型通过定义静态常量为Java代码提供另外一种代码风格，两种风格对比如下

|接受`$`的风格|不接受`$`的风格|
|---|----|
|BookDraft.$.produce|Immutables.createBook|
|BookTable.$|Tables.BOOK_TABLE|
|BookTableEx.$|TableExes.BOOK_TABLE_EX|
|BookFetcher.$|Fetchers.BOOK_FETCHER|

另外，`Tables`, `TableExes`和`Fetchers`是接口，可以使用implements语句来进一步简化代码 *(由于Intellij对静态导入支持不友好，实现定义常量的接口仍然是值得推荐的技巧)*，例如

```java
public interface FetcherConstants
// highlight-next-line
implements Fetchers {
    
    Fetcher<Book> BOOK_DETAIL_FETCHER =
        BOOK_FETCHER
            .allScalarFields()
            .store(
                BOOK_STORE_FETCHER
                    .allScalarFields()
            )
            .authors {
                AUTHOR_FETCHER
                    .allScalarFields()
            };
}
```
